// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const DeleteOrder = `-- name: DeleteOrder :exec
delete from orders
where id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeleteOrder, id)
	return err
}

const DeleteProduct = `-- name: DeleteProduct :exec
delete from products
where price = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, price pgtype.Numeric) error {
	_, err := q.db.Exec(ctx, DeleteProduct, price)
	return err
}

const DeleteUserByID = `-- name: DeleteUserByID :exec
delete from users
where id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, DeleteUserByID, id)
	return err
}

const GetAllProducts = `-- name: GetAllProducts :many
select id, product_name, price from products
`

func (q *Queries) GetAllProducts(ctx context.Context) ([]*Product, error) {
	rows, err := q.db.Query(ctx, GetAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.ProductName, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllUsers = `-- name: GetAllUsers :many
select id, username, email from users
`

type GetAllUsersRow struct {
	ID       int32  `db:"id" json:"id"`
	Username string `db:"username" json:"username"`
	Email    string `db:"email" json:"email"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]*GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, GetAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllUsersRow{}
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.ID, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetOrdersByUser = `-- name: GetOrdersByUser :many
select o.id, o.order_date, o.total_amount, u.username, u.email
from orders as o
         join users as u on o.user_id = u.id
where o.user_id = $1
`

type GetOrdersByUserRow struct {
	ID          int32          `db:"id" json:"id"`
	OrderDate   pgtype.Date    `db:"order_date" json:"order_date"`
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
	Username    string         `db:"username" json:"username"`
	Email       string         `db:"email" json:"email"`
}

func (q *Queries) GetOrdersByUser(ctx context.Context, userID int32) ([]*GetOrdersByUserRow, error) {
	rows, err := q.db.Query(ctx, GetOrdersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrdersByUserRow{}
	for rows.Next() {
		var i GetOrdersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderDate,
			&i.TotalAmount,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserByUsername = `-- name: GetUserByUsername :one
select id, username, email from users
where username = $1
`

type GetUserByUsernameRow struct {
	ID       int32  `db:"id" json:"id"`
	Username string `db:"username" json:"username"`
	Email    string `db:"email" json:"email"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (*GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, GetUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(&i.ID, &i.Username, &i.Email)
	return &i, err
}

const InsertOrder = `-- name: InsertOrder :exec
insert into orders (user_id, order_date, total_amount)
values ($1, $2, $3)
`

type InsertOrderParams struct {
	UserID      int32          `db:"user_id" json:"user_id"`
	OrderDate   pgtype.Date    `db:"order_date" json:"order_date"`
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) error {
	_, err := q.db.Exec(ctx, InsertOrder, arg.UserID, arg.OrderDate, arg.TotalAmount)
	return err
}

const InsertOrderProduct = `-- name: InsertOrderProduct :exec
insert into orderproducts (order_id, product_id, quantity)
values ($1, $2, $3)
`

type InsertOrderProductParams struct {
	OrderID   int32 `db:"order_id" json:"order_id"`
	ProductID int32 `db:"product_id" json:"product_id"`
	Quantity  int32 `db:"quantity" json:"quantity"`
}

func (q *Queries) InsertOrderProduct(ctx context.Context, arg InsertOrderProductParams) error {
	_, err := q.db.Exec(ctx, InsertOrderProduct, arg.OrderID, arg.ProductID, arg.Quantity)
	return err
}

const InsertProduct = `-- name: InsertProduct :exec
insert into products (product_name, price)
values ($1, $2)
`

type InsertProductParams struct {
	ProductName string         `db:"product_name" json:"product_name"`
	Price       pgtype.Numeric `db:"price" json:"price"`
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) error {
	_, err := q.db.Exec(ctx, InsertProduct, arg.ProductName, arg.Price)
	return err
}

const InsertUser = `-- name: InsertUser :exec
insert into users (username, email, password)
values ($1, $2, $3)
`

type InsertUserParams struct {
	Username string `db:"username" json:"username"`
	Email    string `db:"email" json:"email"`
	Password string `db:"password" json:"password"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, InsertUser, arg.Username, arg.Email, arg.Password)
	return err
}
